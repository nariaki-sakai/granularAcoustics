function [U0, paramLattice, EtotVSt] = randLattice(L,Lbuffer,LAbsLayer,p,dk,nNN,strain,a,dispThreshold,quasiStaticDispThreshold,nStrain)

    %[U, paramLattice, EtotVSt] = randLattice(L,Lbuffer,LAbsLayer,p,dk,nNN,strain,a,dispThreshold,quasiStaticDispThreshold,strainStep)
    %   Generates a an equilibrated disordered lattice sandwitched between
    %   two regular lattices, which is again sandwitched between two
    %   absorbing layer. Inspired by what has been carried out by Maxime
    %   Harazi, the lattice is generated by applying a quasi-static strain,
    %   followed by a long relaxation process. The main difference between this
    %   function and the method of Maxime is that the stop criterium of the
    %   algorithm is based on the magnitude of residual motion during
    %   the relaxation process, and not on the duration of the simulation.
    %
    %   INPUT: 
    %       L: size (Ly,Lx) of the disordered lattice. Be careful with the
    %           order, which is (height, width) and not the opposite. In
    %           particular, the guide width is fixed by Ly
    %       Lbuffer: length of the regular lattice (buffer)
    %       LAbsLayer: length of the absorbing layer
    %       p: percolation parameter
    %       dk: parameter for randomness of the spring constant. The spring
    %           constant is generated from a uniform distribution centered at 1
    %           and width half width dk
    %       nNN: number of neighbours of masses, nNN=4 or 8. Determines either we want 
    %           diagonal connexions or not
    %       strain: strain (obviously)
    %       a: length of spring at rest
    %       dispThreshold: most important parameter of the algorithm.
    %           Determines when the algorithm stops. Indeed, it stops when the
    %           displacement of masses during a certain amount of time step
    %           (fixed at 1000) does not exceed dispThreshold times lattice
    %           size (which by convention equals 1). This means that any signal
    %           that are recorded later with simulating waves, that has
    %           amplitude smaller than dispThreshold is noise
    %           quasiStaticDispThreshold: second most important parameter with
    %           nStrain. Determines the degree of relaxation we want after
    %           each strain step. The smaller it is, the longer will be the
    %           relaxation process
    %       nStrain: the other second most important parameter. Determines
    %           the number of strain stage for the quasistatic strain process.
    %           nStrain and quasiStaticDispThreshold both going to infinity
    %           corresponds to a true quasistatic process, but there will be
    %           obvious mega-long running time issues
    %       
    %   OUTPUT:
    %       U0: 2D in-plance equilibrated displacement field of the lattice 
    %       paramLattice: structure variable that contains all metadata
    %           that are important concerning the lattice
    %           paramLattice.kMat: matrix of dimension 3 that contains all
    %               spring contants. For the mass at position (i,j), the local
    %               displacement is U0(i,j) and its spring constants with its
    %               neighbour l is kMat(i,j,l). The neighbours l are sorted as
    %               follows: 
    %               l=1: bottom left, l=2 middle left, l=3: top left
    %               l=4: bottom middle, l=5, top middle
    %               l=6: bottom right, l=7: middle right, l=8: top right
    %           paramLattice.mMat: matrix of size (Ly,Lx) that corresponds
    %               to the values of each masses. When there is a hole, the
    %               mass equals zero, otherwise it equals 1/(2*pi)^2. This
    %               value is chosen such that the natural frequency
    %               f0=sqrt(k/m)/(2*pi) equals 1
    %           paramLattice.strain: the strain is stored in this input
    %           paramLattice.a: length of springs at rest
    %           paramLattice.viscous: matrix of size (Ly,Lx) that contains
    %               viscous damping coefficients of all masses. When the
    %               lattice is created, viscous is non-zero only in the
    %               absorbing layer. But if one wants to simulate wave
    %               propagations in dissipative medium, one can typically
    %               modify this matrix and input in the numerical solver
    %           paramLattice.friction: matrix of size(Ly,Lx,8) that
    %               contains friction coefficients when there is relative
    %               motion between a pair of particles. The last dimension
    %               corresponds to the neighbour l, which are sorted like
    %               kMat
    %           paramLattice.L: disordered lattice size
    %           paramLattice.LAbsLayer: length of absorbing layer
    %           paramLattice.Lbuffer: length of buffer
    %           paramLattice.LtotLayer: length of buffer plus absorbing
    %               layer
    %           paramLattice.nNN: number of neighbours per mass. Indicates
    %               either there is diagonal connexions (nNN=8) or not
    %               (nNNN=4)
    %           paramLattice.p:  percolation parameter
    %           paramLattice.dk: half-width of the uniform distribution for
    %               the spring constant
    %           paramLattice.maxDisp: stop criterium chosen to generate the
    %               lattice
    %           paramLattice.detectorPos: list of positions corresponding to the
    %               transducers. By default, they are placed in the first
    %               columns of the buffer just next to the absorbing
    %               layers. It's a cell type variable of length 2, each
    %               elements corresponds either to the transducers on the
    %               left (1) or right (2)
    %           paramLattice.maxIter: number of time step that was needed to relax the
    %               lattice at the final stage
    %           paramLattice.indSample: file number of the sample    
    %       EtotVSt: kinetic and potential energy versus time during the
    %           relaxation process. Useful to monitor afterwards if
    %           everything went fine
    

    %% CONSTANTS
    
    k0 = 1;
    m0 = 1/(2*pi)^2;
    
    dampingFactor = 200;
    viscousCoeff = sqrt(k0*m0)/dampingFactor;
    frictionCoeff = sqrt(k0*m0)/dampingFactor;
    
    LtotLayer = Lbuffer + LAbsLayer;
    Ltot = [L(1) L(2)+2*LtotLayer];
    
    nIter = 1000;
    dt = 0.05;
    
    
    %%
    tic;
    [mMat, kMat, U0, EtotVSt, tagOut] = randLatticeEngine(L,Lbuffer,LAbsLayer,dk,p,nNN,strain,a,sqrt(k0*m0)/2,frictionCoeff,nIter,dt,dispThreshold,quasiStaticDispThreshold,nStrain);
    toc;

    %% PARAM LATTICE
    
    %GENERATE ABSORBING LAYERS
    viscousMat = zeros(Ltot);
    frictionMat = zeros(Ltot);
    [meshj,~] = meshgrid(1:Ltot(2),1:Ltot(1));
    
    boolViscous = meshj <= LAbsLayer;
    viscousMat(boolViscous) = viscousCoeff*(LAbsLayer-meshj(boolViscous)+1)/LAbsLayer;
    frictionMat(boolViscous) = frictionCoeff*(LAbsLayer-meshj(boolViscous)+1)/LAbsLayer;
    
    boolViscous = meshj > Ltot(2)-LAbsLayer;
    viscousMat(boolViscous) = viscousCoeff*(meshj(boolViscous)-Ltot(2)+LAbsLayer)/LAbsLayer;
    frictionMat(boolViscous) = frictionCoeff*(meshj(boolViscous)-Ltot(2)+LAbsLayer)/LAbsLayer;
    
    %SOURCE POSITIONS
    leftPos = horzcat((1:L(1))',ones(L(1),1)*(LAbsLayer+1));
    rightPos = horzcat((1:L(1))',ones(L(1),1)*(LtotLayer+L(2)+Lbuffer));
    
    detectorPos = cell(2,1);
    detectorPos{1} = leftPos;
    detectorPos{2} = rightPos;
    
    %PARAM LATTICE
    paramLattice.kMat = kMat;
    paramLattice.mMat = mMat;
    paramLattice.strain = strain;
    paramLattice.a = a;
    paramLattice.viscous = viscousMat;
    paramLattice.friction = frictionMat;
    paramLattice.L = L;
    paramLattice.LAbsLayer = LAbsLayer;
    paramLattice.LtotLayer = LtotLayer;
    paramLattice.Lbuffer = Lbuffer;
    paramLattice.nNN = nNN;
    paramLattice.p = p;
    paramLattice.dk = dk;
    paramLattice.maxDisp = dispThreshold;
    paramLattice.detectorPos = detectorPos;
    paramLattice.maxIter = tagOut.maxIter;

end

function [mMat, kMat, U, EtotVSt, tagOut] = randLatticeEngine(L,Lbuffer,LAbsLayer,dk,p,nNN,strain,a,viscousCoeff,frictionCoeff,nIter,dt,dispThreshold,quasiStaticDispThreshold,nStrain)
    
    m0 = 1/(2*pi)^2;
    k0 = 1;

    LtotLayer = Lbuffer + LAbsLayer;
    Ltot = [L(1) L(2)+2*LtotLayer];
        
    %%%%%%%%
    U = zeros(Ltot(1),Ltot(2),2);
    %%%%%%%%
    
    dStrain = strain/nStrain;
    listStrain = dStrain:dStrain:strain;


    %% GENERATE RANDOM LATTICE
    if dk > 0 || p < 1
        %%
        %SAMPLE
        mMat = m0*(ones(L));               %mass random lattice
        kMat = kMatCreate2(k0,dk,L,nNN);  %adjacent matrix: where coeff corresponds to spring constant

        cluster = spanning_cluster(L,p);    %generate percolating network
        while max(cluster(:)) == 0
            cluster=spanning_cluster(L,p);
        end

        mMat(~cluster) = 0;                %remove missing masses and suppress links
        missing_masses=find(not(cluster));
        [ii,jj]  = ind2sub(Ltot,missing_masses);
        for indMass = 1:length(missing_masses)
            for indDir = 1:8
                kMat = symAssign(kMat,0,[ii(indMass) jj(indMass) indDir]);
            end
        end
        %normalize
        switch nNN
            case 4
                kMatROI = kMat(2:end-1,2:end-1,[2 4 5 7]);
                kMat = kMat/mean(kMatROI(:));
            case 8
                kMatROI = kMat(2:end-1,2:end-1,:);
                kMat = kMat/mean(kMatROI(:));
        end

        %OUTER LAYERS
        LLayer = [L(1) LtotLayer];          
        kMatLayer = kMatCreate2(k0,0,LLayer,nNN);
        mMatLayer = m0*ones(LLayer);

        kMat = concatSpringLattice(kMatLayer,kMat,k0);
        kMat = concatSpringLattice(kMat,kMatLayer,k0);
        mMat = [mMatLayer mMat mMatLayer];
        
        %PARAMETER LATTICE FOR SIMULATION
        viscousMatRelax  = viscousCoeff*rand(Ltot);
        frictionMatRelax = frictionCoeff*rand(Ltot);
        paramLatticeRelax.mMat = mMat;
        paramLatticeRelax.kMat = kMat;
        paramLatticeRelax.viscous = viscousMatRelax;
        paramLatticeRelax.friction = frictionMatRelax;
        paramLatticeRelax.L = L;
        paramLatticeRelax.LAbsLayer = LAbsLayer;
        paramLatticeRelax.LtotLayer = LtotLayer;
        paramLatticeRelax.Lbuffer = Lbuffer;
        paramLatticeRelax.strain = strain;
        paramLatticeRelax.a = a;
        paramLatticeRelax.nNN = nNN;
                
        %PARAMETER SIMULATION
        paramSolver.dt = dt;
        paramSolver.nIter = nIter;
        paramSolver.maxDisp = quasiStaticDispThreshold;
        paramSolver.optDisp = 0;
        paramSolver.freqSave = nIter;
        paramSolver.optEflux = 0;
        paramSolver.optOut = 'full';
        paramSolver.fixedBC = ones(4,1);    
        paramSolver.maxIter = 1000000;
        
        %DISPLACEMENT FIELD
        if a ~= 1
            fprintf('\nSTRAIN %2.1f%% / %d%%\n',0,100*strain);
            paramLatticeRelax.strain = 0;
            [U, EtotVSt] = springLatticeRelax(U,paramLatticeRelax,paramSolver);
        end
        
        %QUASISTATIC RELAXATION
        for strainStep = listStrain
            fprintf('\nSTRAIN %2.1f%% / %d%%\n',100*strainStep,100*strain);
            
            if strainStep == listStrain(end)
                paramSolver.maxDisp = dispThreshold;
            end
            paramLatticeRelax.strain = strainStep;
            
            %Affine transformation
            x = 1:Ltot(2);
            y = 1:Ltot(1);
            [meshx,meshy] = meshgrid(x,y);
            Ux = U(:,:,1);
            Uy = U(:,:,2);
            
            Ux(mMat>0) = Ux(mMat>0) + dStrain*meshx(mMat>0);
            Uy(mMat>0) = Uy(mMat>0) + dStrain*meshy(mMat>0);
            U(:,:,1) = Ux;
            U(:,:,2) = Uy;
            
            [U, EtotVSt, tagOut] = springLatticeRelax(U,paramLatticeRelax,paramSolver);
        end
        
    else
        x = 1:Ltot(2);
        y = 1:Ltot(1);
        [meshx,meshy] = meshgrid(x,y);

        U(:,:,1) = U(:,:,1) + strain*meshx;
        U(:,:,2) = U(:,:,2) + strain*meshy;
        
        kMat = kMatCreate2(k0,dk,Ltot,nNN);
        mMat = m0*ones(Ltot);
        EtotVSt = 0;
        
        tagOut.maxIter = nan;
    end

end


function kMat = kMatCreate2(k0,dk0,L,nNN)

    %%

    kMat = zeros([L 8]);
        
    %ASSIGN RANDOM SPRING
    for ii = 1:L(1)
        for jj = 1:L(2)
            if nNN == 4
                for indDir = 2:2:4
                    randk = k0+(2*rand-1)*dk0;
                    kMat = symAssign(kMat,randk,[ii jj indDir]);
                end
            elseif nNN == 8
                for indDir = 1:4
                    randk = k0+(2*rand-1)*dk0;
                    kMat = symAssign(kMat,randk,[ii jj indDir]);
                end                
            else
                error('fdkhfdk');
            end
        end
    end
    kMat(kMat < 0) = 0;
    %kMat = kMat/mean(kMat(:));


    
end

function [kMat, isAssigned] = symAssign(kMat,val,ind)

    Ltot = size(kMat);

    ii = ind(1);
    jj = ind(2);
    indDir = ind(3);
    
    if indDir < 5
    	[iin,jjn] = ind2sub([3 3],indDir);
    else
        [iin,jjn] = ind2sub([3 3],indDir+1);
    end
    iin = iin - 2;
    jjn = jjn - 2;
    iin = ii + iin;
    jjn = jj + jjn;
    indDirn = 8 - indDir + 1;
    
    if iin > 0 && iin <= Ltot(1) && jjn > 0 && jjn <= Ltot(2)
        kMat(ii,jj,indDir) = val;
        kMat(iin,jjn,indDirn) = val;
        isAssigned = 1;
    else
        isAssigned = 0;
    end

end


function [ cluster ] = spanning_cluster( L,p )
%spanning_cluster Returns the mask matrix of the spanning cluster

r=rand(L);
binary_matrix=r<p;

[clusters_labeled,num]=bwlabel(binary_matrix,4);

%% Computing the probability

[probability,spanning_clusters_indices]=probability_to_be_in_spanning_cluster( binary_matrix );

%% Is there a spanning cluster?

is_there_spanning_cluster=probability>0;

%% Removing the particles not in the spanning cluster

if is_there_spanning_cluster
    cluster=clusters_labeled==spanning_clusters_indices;
else
    cluster=zeros(L);
end

end

function [ probability,spanning_clusters_indices ] = probability_to_be_in_spanning_cluster( binary_matrix )
    
    %probability_to_be_in_spanning_cluster Returns the Probability to be in the
    %spanning cluster (if any), given an arbitrary logical matrix.

    L=size(binary_matrix);

    clusters_labeled=bwlabel(binary_matrix,4);


    %% Aire des régions
    clusters_areas=regionprops(clusters_labeled,'Area');
    areas=cat(1,clusters_areas.Area);

    %% Calculating the function P(p,L)

    % Looking for spanning clusters
    clusters_bounding_boxes=regionprops(clusters_labeled,'BoundingBox');
    bounding_boxes=cat(1,clusters_bounding_boxes.BoundingBox);

    % We seek for clusters with horizontal size = L
    spanning_clusters_indices=find(not(bounding_boxes(:,3)-L(2)));


    %% Area of spanning clusters

    spanning_clusters_area=sum(areas(spanning_clusters_indices));

    if size(spanning_clusters_indices,1)==0
        spanning_clusters_area=0;
    end

    probability=spanning_clusters_area/prod(L);         

end

function kMat = concatSpringLattice(kMat1,kMat2,val)

    L1 = size(kMat1);
    L1 = L1(1:2);
    
    L2 = size(kMat2);
    L2 = L2(1:2);

    kMat = zeros(L1(1),L1(2)+L2(2),8);
    for ii = 1:8
        kMat(:,:,ii) = [kMat1(:,:,ii) kMat2(:,:,ii)];
    end
    
    %add links
    for indi = 1:L1(1)
        ind = [indi L1(2) 7];
        if all(kMat(indi,L1(2),:)==0) || all(kMat(indi,L1(2)+1,:)==0)
        else            
            [kMat, isAssigned] = symAssign(kMat,val,ind);
            if isAssigned == 0
                error('error in concatanation of kMat');
            end
        end
    end
    
end

function [U, EtotVSt, tagOut] = springLatticeRelax( U,paramLattice,paramSolver)
    % Propagates a wave in a 2D masses and springs percolated network

    dispThreshold = paramSolver.maxDisp;
    maxIter = paramSolver.maxIter;
    
    mMat = paramLattice.mMat; 
    
    %% SOLVE EQUATIONS

    %Energy for monitoring
    dU = 0*U;
    
    paramSD.detectorPos = [];
    paramSD.forcing = 'position';
    nIter = paramSolver.nIter;
    freqSave = paramSolver.freqSave;
    
    %%
    U0 = U;
    dU0 = dU;
    
    EtotVSt = [];
    
    indt = 0;
    maxDisp = 1;
    while maxDisp > dispThreshold && indt < maxIter
        
        %% SOLVE
        dataOut = verletSolver(U0,dU0,paramLattice,paramSolver,paramSD);

        UvsTime = dataOut.U;
        dUvsTime = dataOut.dU;
        EvsTime = dataOut.E;
        
        if freqSave < nIter
            U = UvsTime(end,:,:,:);
            dU = dUvsTime(end,:,:,:);
            E = EvsTime(end,:);
        else
            U = UvsTime;
            dU = dUvsTime;
            E = EvsTime;
        end
        U = squeeze(U);
        dU = squeeze(dU);
        
        %% MONITOR

        maxDisp = sqrt(max(max(sum((U-U0).^2,3))));
        indt = indt + nIter;
        if 1%paramSolver.optDisp
            disp([num2str(indt) ' - Max Disp ' num2str(maxDisp*100,'%2.4f') '% / ' num2str(dispThreshold*100,'%2.3f')]);
%             toc;
        end
        EtotVSt = [EtotVSt E];
        
        if 0 == 1
            %%
            newfig(1);
            hold all;
            imagesc(mMat);
            quiver(U0(:,:,1),U0(:,:,2),0,'k');
            quiver(U(:,:,1),U(:,:,2),0,'r');
            formatfig(1,[1000 1000]);
            axis equal;
            pause;
            
        end
        
        
        %% NEXT
        U0 = U;
        dU0 = dU;
        
    end
    %fprintf('Energy fluct. = %d',energyFluct);
    if indt == maxIter
        warning('Max Iteration reached');
        tagOut.maxIter = 1;
    else
        tagOut.maxIter = 0;
    end
    
end



















































